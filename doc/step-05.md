# Step 5: module support

In this step, we want to be able to split a Tiny-HDL circuit description
into several files.

We introduce a new construct that brings the entities and architectures
from another file into the current scope.
It takes the following form: `(use "filename")`

To make things simple, all items from the other file are imported.
We also consider that a file exports all its items,
so we don't need an `export` or `provide` construct.

The full-adder example has been split into two files:

* `half-adder-step-05.rkt` contains only the entity `half-adder` and its architecture `half-adder-arch`.
* `full-adder-step-05.rkt` contains the entity `full-adder` and its architecture `full-adder-arch`.
  It imports `half-adder-step-05.rkt`.

You can run this example by typing this command:

```
racket examples/full-adder-step-05-test.rkt
```

# Adding the `use` construct

The obvious minimal things to do are:

* In `lib/expander.rkt`, add a `use` macro that expands to a Racket `require`.
* In `lib/syntax.rkt`, add a corresponding syntax class.

But this is not enough.

Now the tricky part is to make the content of the imported file available
for name resolution and semantic checking.

## Failed attempts

My first attempt consisted of:

* In the imported module, export the root scope object.
* In the importing module, retrieve that scope object, and merge it into the current scope.

To export the scope object, I have modified the macro `begin-tiny-hdl` like this:

```racket
(define-syntax (begin-tiny-hdl stx)
  (define-values (stx^ sc)
    (with-scope* (decorate stx)))
  #`(begin
      (provide #%tiny-hdl-scope)
      (define #%tiny-hdl-scope #,sc)
      #,(with-lookup-cache (resolve stx^))))
```

To import it, I have added a case in function `decorate` like this:

```racket
[:stx/use
 (define* path-str (syntax->datum #'path)
          sc       (dynamic-require path-str '#%tiny-hdl-scope))
 (for ([(k v) (in-dict (scope-table sc))]
    (bind! k v)
 stx]
```

Running the example shows that the scope from `half-adder-05.rkt` is
correctly imported when checking the file `full-adder-05.rkt`.
However, `decorate` fails with this error:

```
scope-table: contract violation;
 given value instantiates a different structure type with the same name
  expected: scope?
  given: #<scope>
```

I understand that `half-adder-05.rkt` is read and expanded in its own environment
where it creates its own structure types.
As a consequence, these types are considered distinct from those available in
`full-adder-05.rkt`.

As a workaround, I have tried adding the `#:prefab` option to my structure types,
so that they are considered as pre-defined and globally shared.
Now, `decorate` fails with another error:

```
in-dict: contract violation
  expected: dict?
  given: #<mutable-free-id-table>
```

This looks like the same problem, but type `mutable-free-id-table` is the culprit this time.
Unfortunately, I can't add `#:prefab` to a built-in Racket type.
What am I supposed to do now?
Implement my own ID table data structure?

## A working solution

In the current working version, I do not rely on *prefab* structure types.
Instead of exporting a `scope` instance, the `begin-tiny-hdl` macro exports
a function `#%tiny-hdl-use` that the importing module will execute:

```racket
(define-syntax (begin-tiny-hdl stx)
  (define-values (stx^ sc)
    (with-scope* (decorate stx)))
  #`(begin
      ...
      (provide #%tiny-hdl-use)
      (define (#%tiny-hdl-use)
        #,@(make-use-body sc))
      #,(with-lookup-cache (resolve stx^))))

(define (decorate stx)
  (syntax-parse stx
    ...
    [:stx/use
     (define* path-str (syntax->datum #'path)
              do-use   (dynamic-require path-str '#%tiny-hdl-use))
     (do-use)
     stx]
```

The body of `#%tiny-hdl-use` is generated by the function `make-use-body`
(see `lib/resolver.rkt`). It creates instances of the `entity`, `architecture`
and `port` structure types, and calls `bind!` to add them to the importing scope.
Interestingly, when it is executed in the importing module, it uses the structure types
available in the importing environment.

This solution works, but I don't like it:
since we already have a valid `scope` object in the imported module,
re-creating all its content in function `#%tiny-hdl-use` seems redundant.
